Adattare al codice pre esistente

Inserire chiamata a edit distance

togliere vectors e mettere new unsigned*

Trovare algoritmo per selezionare i migliori individui tra parents+children

Anziché avere due array, provare ad usare un singolo array diviso da due indici per indicare dove finiscono i parents e dove finiscono i children
[ parents | children]
  <---->    <----> 
   mu        lambda
   
Creare variante (1+1)-ES che usa l'enanched diagonal ed

Per le varianti (1+1)-ES e (1+lambda)-ES fare in modo che, se dopo N generazioni non migliora, stoppare tutto, oppure fare uno shuffle del figlio completamente casuale

Prendi dei campioni ogni 100 generazioni e traccia un grafico nei punti in cui sei migliorato.
Se dopo aver speso G generazioni, dall'ultimo in cui hai migliorato, il return on investment (efficienza economica) è al disotto di un certo margine dato a priori in input, stoppa tutto.
Tratto da un esempio reale con (1+1)-ES_RS
MPED   ms  generazioni
353  4796         5000
358   968         1000
358   468          500
365    93          100
365    46           50

Vai avanti finché la tua efficienza economica si mantiene sopra un threshold dato in input, se scende al disotto, fermati


Trovare rapporto ottimale padre e figli per (mu+lambda)-ES